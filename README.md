PrimalSpec
============

原始的な形式仕様記述言語 (Haskell eDSL)

特徴
-------

1. 状態遷移モデルを直接エンコードせず、CSPライクな記法によりコンパクトかつ直感的な記述が可能です
    * VDMのstのような陰関数の記述も行えます。これによって非決定性も表現出来ます

1. イベント列を指定することで記述した内容についての振る舞いが確認出来ます
    * 太古のソルバ(人間)を使って陰関数や非決定性にも対応可能
    * 仕様に対するユースケース・テストケースの記述としても使えます

1. 内部遷移(τ)と高度な並行合成はサポートしていません
    * インターフェース/アルファベット並行合成はサポートしていません。２つの並行関係にあるプロセスは必ず同期的に遷移します。
    * これは、PrimalSpecの想定記述対象はユーザーとシステムという２つのプロセスのみで、これらの間で共有されるイベントしかモデルに表さないという意図によるものです。
    * 内部選択・隠蔽・リネームもサポートしていません。ただし、非決定性について記述出来ない訳ではありません。

1. モデル検査機ではない
    * 網羅的な検査機能は提供していません
    * デッドロック・ライブロック・詳細化関係についての機能も提供していません

作った理由
------------

* 無料でビジネスにも使えるCSPライクなツールが見つからなかったのです・・・(勉強用なら無料でFDR4が使える)


PrimalSpecでの記述方法
-------------------------------

状態遷移モデルは規模が大きくなると、記述がそもそも大変だったり読み辛かったりします。
この問題を解決する１つの手段としてCSPがあります。これは並行プロセスを記述する為に作られたものですが、状態遷移の記述にも適しています。

PrimalSpecはCSPから終了イベント(✓)と使いこなすのが難しい並行性と内部遷移に関する演算子を取り除いたものになっています。

### イベント

まずはイベントです。PrimalSpecでは主にイベントを使って仕様を記述します。ここでは、イベントとは状態遷移のトリガ、くらいの認識で良いです。

* 基本的に仕様を記述する場合、イベントとはシステム利用者とシステムを構成するマシンの間で共有される現象をモデル化したモノになります。
    * 具体的にはセンサ、通信ポート、ディスプレイ、モーター、時間経過等についての振る舞いです。
* イベントはアトミックに発生します。つまり、あるイベントが発生している間に異なるイベントが発生するといった記述は出来ません。
* イベントにはペイロードをのせることが出来ます。
    * 例えば、```Fill 3``` で自動販売機にジュースを３本補充するというイベントを表すことが出来ます


### プロセス式

PrimalSpecでは、プロセス式とはイベントがどういう順番で発生しうるかを表現している式だと思って下さい(トレース意味論)。

プロセス式はイベント、原始プロセス、合成演算子によって構築されます。

* 原始プロセス
    * ```Stop``` : いかなるイベントも発生しないプロセス式。異常終了やデッドロックを表すのに使う。
    * ```Skip``` : いかなるイベントも発生しないプロセス式。正常終了を表すのに使う。逐次合成や割り込みの振る舞いがStopとは異なる。
* 合成演算子
    * ```ev --> P``` : プリフィクス演算子
    * ```ev ?-> \x -> P``` : 受信演算子
    * ```ev &-> P``` : ガード
    * ```P1 |=| P2``` : 外部選択演算子
    * ```P1 <|> P2``` : 割り込み演算子
    * ```P1 >>> P2``` : 逐次合成演算子
    * ```P1 <||> P2``` : 並行合成演算子


### 遷移と規則の記述方法

プロセス式P が イベントaを受理した後プロセスQとして振る舞うという命題は以下のように表現します。


       a
    P ===> Q


各命題に対して仮説部（線の上側）が全て成立すると結論部(線の下側)の各命題がそれぞれ成立すると読んでください。以下の場合、(P かつ Q) ならば (R かつ S) です。論理学とは異なり、(R または S) ではない点に注意して下さい。


        P
        Q
    ----------
        R
        S


### Prefix演算子

```a --> P``` は イベントa を受け取ったらプロセスPとして振る舞うプロセスを意味します。


    ------------------
                a
     (a --> P) ===>  P


式の外で指定されたイベントのペイロードを使いたい場合は、受信演算子を使います。つまり、P の中でxはペイロードの中身を指します。


    -----------------------------
                        a.y
     (a --> \x -> P(x)) ===>  P(y)


### ガード演算子

    (b &-> P) := if b then P else Stop

### 外部選択演算子

```P |=| Q``` は P またはQとして振る舞います。P,Q のどちらのイベントが先に起こった方が選択されます。


    a != b

       a
    P ===> P'

       b
    Q ===> Q'

    --------------------
               a
    (P |=| Q) ===>  P'

               b
    (P |=| Q) ===>  Q'


PrimalSpecでは a = b の場合は定義されていません。


### 逐次合成演算子

       a
    P ===> P'

    -------------------------------------
               a
    (P >>> Q) ===>  (P' >>> Q)

かつ

       a
    P ===> Skip

    -------------------------------------
               a
    (P >>> Q) ===>  Q


### 割り込み演算子

    a != b

       a
    P ===> P'

       b
    Q ===> Q'

    -------------------------------------
               a
    (P <|> Q) ===>  P' <|> Q

               b
    (P <|> Q) ===>  Q'


かつ


    a != b

       a
    P ===> Skip

       b
    Q ===> Q'

    -------------------------------------
                       a
    ((P >>> R) <|> Q) ===>  R

                       b
    ((P >>> R) <|> Q) ===>  Q'


### 並行合成演算子

完全に同期するような並行合成です。


       a
    P ===> P'

       a
    Q ===> Q'


    -------------------------------------
                a
    (P <||> Q) ===>  (P' <||> Q')


かつ


       a
    P ===> Skip

       a
    Q ===> Skip


    -------------------------------------
                a
    (P <||> Q) ===> Skip


### その他の簡約ルール


* (非決定性が含まれなければ)プロセス同士の２項演算子において、割り込みと逐次合成以外は交換則が成立する
* ```Stop |=| P == P```
* ```Skip <||> Skip == Skip```


### プロセス変数とペイロード

プロセス式はHaskellのeDSLで記述されます。

プロセス変数というものは存在しませんが、
Haskellの関数を使ってプロセスを抽象化することが出来ます。
関数なので引数を使えば、インデックス付けられたプロセス式の表現も可能になります。

```
heater :: Int -> Process
heater n = Up --> heater (n+1)
```


### SuchThat

SuchThatによって陰関数や非決定性を表現出来ます。

```haskell
s_t_ :: String -> (a -> Bool) -> a
```

以下のように使えます。

```haskell
f :: a -> b
f a = s_t_ "message" \ret -> p a ret
    where
    p :: a -> b -> Bool
    p = xxxxx
```

ただし、動作させる場合は自分で答えをコンソール等から入力しなければなりません。
答えが間違っていたらエラーになります。


記述例
-----------

では、実際に PrimalSpecで自動販売機の仕様を記述していみましょう。

demo/Main.hs

をご覧下さい。


参考文献
---------

* "Concurrent and Real Time Systems: the CSP approach" (S.Schneider) の前半



